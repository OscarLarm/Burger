5/9 What we started with was deciding our git terminal (github) following with configurerating it and connecting our computers to the github server by creating our unique ssh keys. This was something we had a bit of struggles with but by looking at github's documentation on how to do it, the problem solved itself. Following that we aquinted ourselves with some typical git commands by testing them in our respective terminals. Such as git add, commit, pull, push, branch and checkout. add, commit is used to save our work on git, while pull and push is taking files from github and respectivly sending new updated work from our local devices. Branch checks what current branch we are on and checkout creates a new branch. As we were working we where pulling and pushing from the main branch all at the same time which resulted in problems such as delays and github acting strangly, therefore we quickly decided to create a developement branch from the main one and from it create our respective branches that we merge with the developement one later. What i believe to be a difficult aspect of this exercise is getting an understanding on all the tools and then putting them together into a functioning application. But I belive that little by little it will come together. My key strategy will most likly be familarising myself with one aspect of the program and working from there. Personally I might add that another diffuclity can be working together in a group and dividing the work between us as we all have different workflows and ways to go about problems. But at the same time I feel this is a reasurrance, since dividing up a program in pieces and distributing them between multiple individuals reducing the overwhealming feeling I have now. 

6/9 Ive begun by looking into some of the tools that we will be using for the assignment. As I believe familarising myself with them on atleast the surface level will give me a better vision of how the program will function as a whole. I mainly started with the containerization of the program and the tool I think we will use which is docker. It is something I have no experience or understanding of what it is and how it works (containers in general that is). After grasping a bit on how it works, by looking up explenations on youtube and reading about it on dockers website. I continued by downloaded docker to my terminal and created an image and ran a container from a tutorial on dockers website, including the test exercises that were provided in this course( I'd say it went alright). I feel there is alot ive not yet grasped and there is questions in my head about how to apply this and set it up for our project. I look forward to looking into it more.

7/9 Our group had another meeting to go through the "Get started points" and start planning. We created our "amazing" menu that we will provide for our humble customer. We followed by created a bit of a mind map, diagram with lucidchart to better visualise the different aspects of the program and how we think they relate to each other. To then decide what part each one of us want/should look into more, of course we all want and need an understanding in all the areas of the assignment. But its good to split the workload between us. Personally I wanted to continue looking into docker and container systems to start with. 

10/9 Today I looked into how to created a compose.yml file which is the blueprint of instructions for starting all the containers with the "docker compose" command (database, the kitchen view(decided on it being a python script) and the user interface). Looked into what instructions might be required to add for our application and its respectivce containers. Only added parts of it as I am still unsure if im doing it correctly or not, so will have to go back and re-check it when Ive acquired more insight. Wrote a prototype python script for sending and getting request from our webapplications, in other words, reciving and parseing the Json file with the order through a REST-api. I did this with a simple Get() funktion provided with the requests library of python. Which downloading that itself took some figuring out, as I accidentaly installed a bunch of libraries I did not want and the request library still did not want to work. Had to uninstalled the packages I got and looked up exactly how to download the individual library I wanted. After some trial and error got it working. Now what I am waiting for is getting the web application running (something my dear coworkers will look into) so I can test the python script (kitchenview part of the program)  

12/9 On todays laboration we went over the debugger and got to well.. debug a program that was kindly provided for us. I have had a bit of experience with this type of debugging previouslly both from our python course and before that. What mostly intruiged me was the tests that signaled something was wrong with the program. It something we read about in the recommended course book and it sparked a curiosity on how you write these test scripts. But the debugging went smoothly I did it in InteliJ an IDE I have not used before, but I found it easily understood and helpful. After the lesson our group took some time to go over what all of us had done while we merged our respective branches with the developement one and pulled the updated one to our local systems. We decided on ideal deadlines for the different parts and how much time we expect we need for them and wrote them down. The next step is to finish our respective parts and put them together and test them, to later do individual debug sessions, which after todays laboration is something I dont think we will have problems with.
Personally I will take time and read up on more parts of the project even if I am not neccesarly responsible for. 

17/9 Other than going to todays lecture, which I have to say was good for getting a clearer grasp on the assignment. It showed that the way I and my team had gone about the assignement was in the right direction. Nontheless I begun looking into Javascript and how to use frameworks like express. As well as connecting to our database which in this case was decided to be MongoDb, a NoSql(Not only Sql), which to my understanding is that you store data in a more unstructured way, which for example lets the data be updated and changed more rapidly. I understood it that one way of doing this is by using node.js (A term I hear be thrown around, but I dont yet know exactly what it is) and downloading packages for both express(to host the website locally) and the mongoose package to handle the database. From there using the mongoose set up a connection from the website to the database. I believe we have to then use the find() function and gathering the needed data and storing them in a array and afterwards have a for-loop add the data to list items <li></li>.

18/9
After todays lecture about documentation, I took a second to think about my conceptions on how to use comments and how Ive used them in the past. I fell into the catagory of over commenting everything, which now I see is definetly a bad practise. Although Ive used them mainly to explain my thought process to teachers reviewing my code, but it forms a bad habit. I could easily see the difference between self explanitory code and comments. Have now been forcing myself to take a while to think of how I could structure my code more readibly and mainly come up with better naming sense (which can be quite difficult). 

22/9 
Today I continued looking at the compse.yml file, added more instructions especially for running the kitchenView script. Made it so it wont start until the website has been launched, by using the "depends_on" keyword. I also started looking into networks with docker. There by thinking if it could be useful for our project. From what I understand the obvious benefit would be easy communication between the different containers. Although putting them all in a singel shared network creates some safty hazards and isnt good praxis, it would be better to create for example a network for frontend and one for backend, by doing so they are isolated from one another. But when thinking about it for our project, yes we could use it but it feels uneccesary, this because how the containers are setup. That is we have one container for each part rather then having divided it up like I mentioned with frontend backend and database containers instead. Because now the front and backend of our website gets launched from the same container. I may have understood it wrong, and I feel I would need to dive deeper into the topic.   

24/9 After todays lecture that went over virtual machines and containers, I looked over my own work and reflecting on it. I believe I had understood how it works and got the concepts correct. What I did do was add a requriements.txt file where the python requirements (libraries) can be stored as I heard Michael mention it, it works in the same way as a package.json file for node. I had thought if I was gonna do "pip freeze > requirements.txt" to add all pip dependencies. But thought it unnecessary as we will only use the request library. Instead I looked up the latest version of requests and added it, in the dockerfile for the kitchenview I also added "RUN pip install -r requirements.txt" which checks the content of the textfile and installs the pip libraries.

26/9 On todays lab I started to look into how to send a order to the kitchenViewer, since we are using nodejs express for our server, loading a static html page from it and creating apiendpoints. I looked at the qfstandalone(v3) code that was used for the docker exercise, studied the code and looked how michael had done it. My thought was to try and get items from a hardcoded array down to the static website as checkbox items to have some thing to test. I looked at Michaels python code and did a similar thing in javascript. But was unable to get them to appear on the website. 

27/9 Today I continued with what I was doing yesterday, sat down and researched how I could be able to get items down on the page. I managed to do it by creating a api endpoint on the server where the items would be and made a fetch request to said api in the javascript code for the website. After getting the items as text I got a html div and inserted the text with .innerhtml. After that I needed to get functionallity and started looking into how to store the checkbox items into an array, when you press a button. I did this by using queryselectorall on the checkboxes and looping them, checking if the items were checked if so stroing them. Next hurdle was to get the selected items back to the express server. I struggled a while but created a post api, and did another fetch this time sending data to the server. For this like most of everything looked for information online taking bits and pieces seeing if I could implement it. I tried starting the website locally with by running node index.js. Consol.logging the item on the frontend and on the server in the postrequest to see if it got sent properly. Which after some trial and error and one spelling misstake or two, (javascript is annoying sometimes...).
I also tried running docker compose after downloading the neccesary libraies for it on ubuntu. Which got alot of errors, both on the kitchenview and the server, I commented out the database because I would not be in need of it yet, since Im just testing with a hardcoded array. I read the error messages and tried fixing them and finally I atleast got the server to work. The kitchenView still needed some more love...

29/9 I continued with getting the kitchenView to work and it was complaining because it just kept throwing error (requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=8080): Max retries exceeded with ur). 
As Im writing this I dont know exactly what I did, but one thing I got from it is that when running it with docker it is not responing to localhost, but instead the container name of the website. I also put it in a try, except, catching requests.exceptions.RequestException. I then continued trying to send the data to kitchenview from the express server through a fetch. But I didnt get it to work, as I think fetch can only send or retrive data from a url and kitchenview doesnt have one. Instead I created a endpoint inside of the post that retrives the order, doubt its that got praxis but I atleast got python to respond... well with an error message saying TypeError: the JSON object must be str, bytes or bytearray, not Response. Currently in the process of resolving this.



30/9 I realised that its better to run the kitchenview in its own webserver, as a script would continously run with the restar always command in docker, and while I think I could make it to work, it seems very ineffiecent and pointless. Thats what I get for being stubborn and sticking with my first perception of the assignment. Since I was already using python with my previous idea, I decided I wanted to try setting up a webserver with python as Ive already tried it with node express for the burgerorderer side of the project. Therefore I started looking into how to download the python library FLASK which is used for this job. Begining with installing pip which helps download python packages, similar to running NPM to install packages in node. Had some issues at first since I accidentaly downloaded EVERYTHING, and I only wanted the specific library, I looked up how to remove pip installations and did the process again but this time specifying to download FLASK. Because of how python is with its needed virtual enviorments to deal with downloads I had to change the enviorment I was in. Which made it possible to run the program and I got a api endpoint up and running. But instead of running manually from vs code I did some changes to the docker file to work with Flask instead for example giving it a port to respond to inside docker container, updated the requirements.txt file with flask installation. I created another endpoint that I want burgerorderer to send the order to. I made the endpoint as a get, but I did not get the kitchenview to respond. Looked around a little and realised I should use the Post method instead. I got it responding with status code 200, but it did not print anything. I tried a bunch of stuff, one being storing the order in the url, as well as sending it as a json package and retrieving it with flask request package. But its still not sending. 

1/10
Continued with trying to get python flask to print out the recived orders, spent a long time googling trying different things. When I sent it in the url it said [object,object200%] meaning the object I sent was not converted to a string, solved this by using JSON.stringify on the items when concatinating the url (shoutout Oscar for the assistance) Although now I got the order items in their string format the problem of printing it out was still there. I added a return value in the python post function and got burgerorderer to print the response, meaning that the body of the function was executing which is what I thought the problem was at first. I kept trying to solve it and it was finally later in the day i decided to take a sneakpeak at Michaels version and saw that he had put ENV PYTHONUNBUFFERD = "yes" in his dockerfile, so I just decided it may be worth trying adding that not expecting anything to change, but low and behold that fixed it and I could see the print out. I then googled what it did (I know I should have done so before using it but I was at a loss). Basically I understand it to take the python output (stdout stream from C which python interpreter was built with) and displays it in the terminal from you container. Instead of take the items from the url I was already sending a package object as a json therefore I used flask's request.json function to parse the object and print it out to the terminal. 

2/10 
Now that I have got burgerorderer to send a object array containing the selected order (only the burger name), the next problem was to let the user customize it and be able to remove ingredients. I began by first adding ingredients to my static menu and added a nested forloop that runs after a burger name has been added as a listitem containing checkbox. Adding more listitem checkboxes. I was thinking then how to create a relationship between the "parent" burger name and the child "ingredients". After googling I stumbled upon the term nested checkboxes and I though I could use this. I then modified the content of the loops to create items, adding the ending li tag at the end of the forloop for ingredients. Which resultet in the checkboxes appearing indented on the page, well after commenting out some css properites. Still there was no relation ship between them. I then decided to add classes to the checkboxes to distinquish them from one another. "parent" for the burger name and "child" for the ingredients. My idea was that I could check which ingredients where unselected by looping from a checked parent. For this I needed to add an eventlistener for checking a box, and my idea was checking if it had the parent class start looping the checkboxes under it and checking if there were children that was unchecked and stopping when it reached an unchecked parent. I also wanted all children to check when a parent was selected, thought I could do a similar thing as previously mentioned. I tried a bunch of different ways that I both thought of myself and looked up on google, of course they needed to be modified but none worked. I then saw some people using queryselectorAll to store the checkboxes in lists of nodeobjects. But I did not get it to do anything. I then began putting console.logs inside the code after something was suppose to happen, I for one logged the creation of the variables storing the list of nodeobjects and saw that they were not added for some reason. I did the same with all list items and got the same thing. Which made me think the fetched html items for the menu got read in after queryselector ran. I checked this by adding a list object with the child class to the static page and re ran the program. Which confirmed my suspistion since that one got added. I wondered long and hard about why, trying a bunch of different stuff, such as setting my fetch request for the html elemetents in the top in a function call and putting the queryselectors lower in the js document, thinking since it would read from top to bottom in a cascade it would add the html first. It did not.. I tried adding the fetch to the html document directly in script tags, it did not work.. Looked into async and defer properties on the script src tag, it did nothing. So what I then saw and tried was adding the javascript file in my fetch function after it added the text object as html with the following lines of code: var script = document.createElement("script"); script.src = "burger.js";
document.body.appendChild(script);. This worked since the html by that point is already there. This is not a pretty solution and definently not a good way of doing it, but.. it works. 

4/10
Now that I had got the queryselectorAll working and storing the different checkbox items by their given class. I could now start looking into how to check all nested children. I started by looping the parent boxes and adding a onclick function on them. My next step was making it so it would loop the checkboxes and selected all ones containing the childclass, but first I tried if there was a more elegent way of doing it, looking at the .children() function to get all nested html objects within a tag, but for some reason I did not get it to add them, so I instead went to my original plan. To my joy I finally got something to happen, only problem was it checked all children boxes on the page. I then added another if statement that checked if the next index was a parent and if so check the current iteration and afterwards break. This worked, well on the first menu option, if I clicked on the one bellow it, it would check all children from the first parent. I understood the logic of why it did this as it just looped all checkboxes from top and stopping at the first parent. I therefore needed to get the index value of the parent that was clicked, I tried a bunch of different ways. Like getting the index of the clicked parent and starting the loop from there, but forgot that the index of the parent checkbox list items are different from the checkboxes. Therefore if i clicked the third parent it would start looping from that index. I needed to find the parents index in the checkbox elements. Added a for loop that checks if the values are the same and then gets that index, and then I could start looping and checking for children from that index instead. It worked on everything but the last as I got a error saying it was undefined. But I left it as it was as Oscar had also been doing it and got it working, we decided to both try it as we were behind schedule. But I still want to get it working.

5/10
Today we decided to have a meeting and put everything together, we decided to go with Oscar's version of the sending mechanism, but I dont want to deleate the work Ive done, therefore we added another folder in the root called other_version, and in that I created a folder called Gabriels_version where I added all the stuff to run the program. And since Oscars version hade to node applications I helped Malte with creating a dockerfile for it as well as modifiying the compose file. We had some problems starting it because both needed the package.json file to run npm install, and tried specifying the location of it in the dockerfile. Using ../../package.json as they were in the root file, but it did not want to work. So kinda gave up on that idea and istead copied the package.json file into the respektive folders. We also uncommented the database from the compose file which I commented out because it threw an error, but luckily it wanted to be nice today and worked fine, think it needed some time to calm down.. After running the docker the database started to spitt out alot of text in the terminal which we didnt want. Googled a little for a solution and solved it by adding the command "command: tail -f /dev/null" into the compose file. 

6/10
Today we had another group session and we realised that my user on git was wrong, and all commits ive made has fallen under the user "gabriel-", realised the reason for it was that when I orignally created the ssh key, I had made a typo in my email adress that is connected to github. We looked up how to change my local git email and username which worked eventually. But the problem was that all my previous commits was not tracked under my github account. So we wondered if there was a way to change it, we saw a bunch of different soloutions to do it. Since there was a lot of commits I did not want to waste time and change them all manually with git rebase -i -p and the commit id. But it was a bunch of different id's and you could not tell which was which. We then saw you could use a pip library and write a script in python to do it: 
git filter-repo --commit-callback '
    if commit.author_name == "wrong_username":
        commit.author_name = "correct_username"
        commit.author_email = "correct_email@example.com"
        commit.committer_name = "correct_username"
        commit.committer_email = "correct_email@example.com", 
        Changing the text in the quotations to match my own username and email, before and after.
Although they did not recommend this, but us being ignorant youth did not heed the warnings, and continued on regardless not knowing the consequences. The outcome was that nothing changed, well not what was intended, becuase we instead got a whole bunch of git problems on my computer, as I could not pull down from the server, I could not push as my branches contained no common history base. For pushing I had to first modify all my branches to match the origin branch and then using git push --set-upstream origin branch-name. Thankfully we did all this testing on nonimportant branches to atleast not cause problems on the main or development one that was up to date. Because we realised after I did a push we doubled the amount of commits. Since I had already done commits and pushed up my stuff prior to this mess, we decided to remove the branches that I had doubled the commits on and I would then remove the git repo from my local computer and copy it down once more. Basically doing a hard reset. After this mess that took hours I decided I have a grudge against git, and will leave all my prior commits on the wrong username as it is and let my proffesor know that all commits done by "gabriel-" belong to the user "Gabe-Hog". 
Afterward I started documenting my code I wrote for my version of the program, commenting functions and things I felt needed more explaination. We had looked up good documenting praxis for Javascript and followed their recomendation. I also started to look if I could fix the bug in the selecting all child checkboxes. Which I got working when seeing I had a condition for the next loop instance that shouldnt have been there.

7/10
Today I started looking to set up being able to debug our node applications in a container.- I started by reading what was provided in the assignment description, and tried following their examples. But since our files look different from the example it would not work, so I headed out to the wide web and started reading up on other examples of doing it, taking bits and pieces and trying out. I made a compose.debug file that overrieds parts of the original compose file (Very handy of docker to be able to do this I think) to run a node function for debugging "start-debug": "node --inspect=0.0.0.0 KitchenView.js". When researching I saw more ways to set up a program in docker, for example you could have multiple image versions in one dockerfile, for example you could have one for production one for testing and one final one. When I tried running the program in debugg mode I got some node/module errors that I was not sure how to solve. So I tested my way forward removing modifying my package.json debug script, until finally it didnt throw errors. Next step was to add a launch.json file that the debugger in vs code would use. I pretty much copied one example I saw and thought could work, not understanding everything it did, but trying to the best of my ability. Basically you specify a name for the debugger, what type it is, stuff like what type of request specify a port that needs to match in the compose.debug. The docker directory as well as your local one. Then when running the debugger it attached but my breakpoints did not work. I started looking to why this occured and found that I had not specified the local directory of the program correctly, I had set it tot the root and not the specific folders. After modyfing it, the debugger worked. I tried it out and looked what happened, not much since alot of the program gets executed in the burger.js file and the node app basically just sends a post request to the kitchenview. I did get to go on a nice journey through different node modules and see what for example the fetch function did.

8/10
Today I began with setting up a debug enviorment for the kitchenView it was not anything hard, just had to update the launch.json file with the same instructions as the burgerOrderer, with some slight modifications such as the localroot directory and the port, chose 9230, as 9229 is the standard for debugging in node, but it is already used for the burgerOrderer. Then updated the compose.debug file and added the commands for the kitchenView along with it responding to port 2230 on the local and reused the 2229 in the docker, since it doesnt affect it. I also started looking into the test framework we will be using called Mocha, added it to the package.json. Also saw a lot of people using something called Chai along side it, and from what I understand its commonly used together. While Mocha is a test framework that gives different functions to be executed in a certain order, and log the results in the terminal, with syntax such as "describe" and "it". "it" being the actuall test to be executed and "describe" is used to group test of a functionality
together. Chai is more of a library of assertions and assertions being the test cases, that expects a certain result from said test, for a test to pass all assertions must be met. I also got reminded of what I read in the course book that tests should be created before actually starting to code, so its something we actually should have started with, as well as planning the tests. But I think its especially hard to do this for beginners as we have not become accustomed
to both visuallising how the program will look as well as estimate what it needs to pass. But it is definently something I will practise and think of in the future. 
We as a group also sat down and started writing a simple plan over how our tests and what we will test as well as how our debugging should go. Again something we should have done way earlier, but you live and you learn. 

9/10
Today we started with getting our test framework to function, adding chai and chai(http) to our package.json file. Making a test folder inside the burgerOrderer. With a file called test.js in which we will write all tests for the burgerOrderer. Exported our express module "app" and imported it to the test. We looked at how to actually run the tests by modifying the test script. At first we wrote a node enviorment to check if it should do the debugging, by running npx command, which was a struggle to get working. But later we scraped it by making another override yml file, like we did for the debugging, but this time it being called compose.test.yml. To run these things we also have a makefile, where we store different run commands. This made the whole process way more effective, now we can for example write "make up" to run the docker containers or "make test" to run the docker containers as well as the test scripts. I still think there could be a simpler way to run the tests without having to relaunch the docker containers everytime. I tried making volumes to match the local files to the docker files to make it easier to make changes and imporve the development enviorment, but for some reason it did not want to work. Because when running docker it could not find the package.json file. We then started writing a test for one of the api endpoints we had singled out the day before called "/order". We first used describe to make a test group, and then proceeded writing a "it, that sends a request to the enpoint with a object and checks if the response is a string. We didnt really get it to work as we got assertion errors, because it wanted the return to be an object as well. 

10/10 
We sat as a group and continued with the test framework, trying to get it to work, we got the first test running by changing out the "response.body.should.be.a("string")" to "response.text.should.include("name of the burger")".
Continued with writing some more tests for different functionallitys like if it got the wrong input it, and it should not respond in a certain way. We also tried writing tests for the database to see if it starts, and test the endpoint that gets data from it to see if it returns items. But we didnt get it working spent alot of time trying to get it to work. The problem we most often faced was it passed the tests even if we didnt start the database.

## Debug
13/10
Today I did my "scheduled" debugg session, as previously mentioned I dont think there is a whole lot to debug since alot of the functionallity happens in the burger.js file, but nontheless I plan on testing out a few different menu options and seeing what happens inside the program. Before I launch the program in debugg mode using our "make debug" command which runs the command "docker compose -f Containers/compose.yml -f Containers/compose.debug.yml up --no-attach mongodb" which first runs the normal compose file and then runs the override debugg compose file, connecting the node debugger in the container, the added "--no-attach mongodb" makes the database run in the background and not print anything to the terminal. But as I said before this I put out breakpoints in both the burgerOrderers index.js file, I place them in the beginning of every function, because I want to see every process the program goes through by starting from them. Since I am using vs code after running the "make debug" I go to the vs code debugger and select the program I want to debug (from the specified once in the launch.json file) I will start with the burgerOrderer (cant debug both programs at once). After attaching the debugger the program stops at my first breakpoint, which is in the api endpoint /database, that gets the data from the database and sends it back as a response. Since I want to begin and see what happens I use "step into" to make steps through the execution of the program. Which sends me into the node module function "find" which is used for finding data in the mongodb database, with the node module mongoose. As I keep stepping into the functions Im getting sent to different functions that "find" uses. I look at it and try to understand what exactly it does, but it is a bit hard to get a grasp on, therefore I want to get back to our program and use the "step out" command. Which steps out of functions just like the name says. I could use "step over" but that would mean I need to keep steping over every step in the function, so instead I just step out when I get to a new function until I get back to our program. When I get back it keeps using the find method so I step over that process. As I did I see our menu appear on the html page, which is generated in the burger.js file. After I get stuck in an almost endless loop as I steped into the resopnse and it goes between the function "emitHook" and "destroy(asyncId)" which has something to do with promises I think. Either case since this is part of the node modules I use "Restart" to get out of it and removed the breakpoint in the /database api endpoint. Now I see the page as normal and to get to the next debug point, I decide on a menu item I want to order. I chose an "Original Chicken Burger" without bread because carbs. When I click the button buy, the program stops at the next breakpoint I set, which is in the post api endpoint "/order", where our order is processed. I want to see what happens to the variable "data" there. So in visual studio code you can add a variable name by writing in in the "watch" box. This lets you track specific variables and see what happens to it. Currently the data variable contains an object {foodItem: '"Original Chicken Burger", ingredients: 'Bread'}. As I continue to step into as I want to see what happens (also stepping over all node module functions), I get to our function sendToKitchen. Which as name suggest sends our order to the KitchenView, by using a fetch method on its api "http://kitchenview:3001/order", notice its not localhost:3001, this because its run in a docker container and using its network therefore the adress name needs to be the name of the container. I did not get to follow the program into the kitchenView as I said previously you cant run the debugger on two containers at once. Instead it moves on to another function that gets called in the post end point, which is orderPage(). That processes the order and formats it to html to display on a website saying this order has been sent. Since it takes the data as argument and uses the JSON.stringfy() method, to turn the json object to a string and uses it to get the food items from it. Which is inturn added to a variable called "page". Therefore I want to track this new variable as well, manuvering to the watch box and clicking add and writing the variable name. When I do so I see it is a string, with html tags and texts gets added to it and when Ive arrived at the end of the function it returns page variable containing the string: "<h2>Order sent!</h2><a href = \"/\">Back</a><hr><p>One Original Chicken Burger with Bread." and it uses res.send() with the returned variable as parameter. Then I see a new webpage opened up called "localhost:3000/order" displaying a message that my order has been sent. After that the debugging ended. Since there is nothing more the program does. Now I want to see what happens to my order in the kitchenView, therefore I rerun the program and swapping the debugger to the kitchenview, and ordering the same item. Now I see that the website telling me the order is sent appeared and I am inside the kitchenView.js file in the post "/order" endpoint. Since the variable is still called data I dont need to add it to the watch list. I can just use "step into" and see what happens and it will update, I can sumize that it is the same object as in the kitchenView meaning it got sent succesfully. I continue steping in and the program calls the getOrder() function within a console.log(), which will print the order to the terminal from the kitchenView. I add the variable used to the watch list called "message" which will containe the string that will be created, first it adds the name of the item ordered and then it checks if there are a key called "ingredients" which there is being bread. Then it adds "customized with" to the variable and creates a empy array and adds the ingredients to it, afterwards it used the join() method to turn the array items into a string seperated with a (", "), then finally concatinating the string to the message variable, and returns it. That is the end of the debug session. I think it was fairly easy to navigate through it once I had set up the enviorment to do so in a container. It is much similar to previous experiences using the debugger in different languages, such as C#, python, Java and now Javascript. I think it is a valueable tool to see exactly what your program is doing and why, instead of relying on luck and coincidence, making changes and just trying different soloutions till one of them works. It may feel slow but it is very effective when you want to find and isolate a bug. I also believe it makes you better at understanding programming especially as a beginner, because with it you see exactly what your code is doing. The only downside I thought with debugging the node application, is it doesnt enter the javascript code for a static html website. Because of it I think you miss out on things the program does, all we could really do now was test so the endpoints and the functions within them does what they are suppose to, and another annoying aspect is entering all the node modules and built in functions the program uses. When you only want to debug you own code, not look at code someone else has made and you more or less expect to work as it should, stepping out of the functions speeds it up for sure and I couldve steped over the function call, but it would be nice not having to do so, maybe i am just lazy. 
